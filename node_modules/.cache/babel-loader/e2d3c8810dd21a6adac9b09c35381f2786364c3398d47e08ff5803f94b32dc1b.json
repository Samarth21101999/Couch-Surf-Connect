{"ast":null,"code":"import crypto from 'crypto';\nimport { urlAlphabet } from './url-alphabet/index.js';\nconst POOL_SIZE_MULTIPLIER = 128;\nlet pool, poolOffset;\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);\n    crypto.randomFillSync(pool);\n    poolOffset = 0;\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool);\n    poolOffset = 0;\n  }\n  poolOffset += bytes;\n};\nlet random = bytes => {\n  fillPool(bytes -= 0);\n  return pool.subarray(poolOffset - bytes, poolOffset);\n};\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;\n  let step = Math.ceil(1.6 * mask * defaultSize / alphabet.length);\n  return (size = defaultSize) => {\n    let id = '';\n    while (true) {\n      let bytes = getRandom(step);\n      let i = step;\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || '';\n        if (id.length === size) return id;\n      }\n    }\n  };\n};\nlet customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);\nlet nanoid = (size = 21) => {\n  fillPool(size -= 0);\n  let id = '';\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += urlAlphabet[pool[i] & 63];\n  }\n  return id;\n};\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random };","map":{"version":3,"names":["crypto","urlAlphabet","POOL_SIZE_MULTIPLIER","pool","poolOffset","fillPool","bytes","length","Buffer","allocUnsafe","randomFillSync","random","subarray","customRandom","alphabet","defaultSize","getRandom","mask","Math","clz32","step","ceil","size","id","i","customAlphabet","nanoid"],"sources":["D:/MERN Stack Project/CouchSurfConnect/client/node_modules/nanoid/index.js"],"sourcesContent":["import crypto from 'crypto'\nimport { urlAlphabet } from './url-alphabet/index.js'\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\nlet random = bytes => {\n  fillPool((bytes -= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) => {\n  fillPool((size -= 0))\n  let id = ''\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,QAAQ;AAC3B,SAASC,WAAW,QAAQ,yBAAyB;AACrD,MAAMC,oBAAoB,GAAG,GAAG;AAChC,IAAIC,IAAI,EAAEC,UAAU;AACpB,IAAIC,QAAQ,GAAGC,KAAK,IAAI;EACtB,IAAI,CAACH,IAAI,IAAIA,IAAI,CAACI,MAAM,GAAGD,KAAK,EAAE;IAChCH,IAAI,GAAGK,MAAM,CAACC,WAAW,CAACH,KAAK,GAAGJ,oBAAoB,CAAC;IACvDF,MAAM,CAACU,cAAc,CAACP,IAAI,CAAC;IAC3BC,UAAU,GAAG,CAAC;EAChB,CAAC,MAAM,IAAIA,UAAU,GAAGE,KAAK,GAAGH,IAAI,CAACI,MAAM,EAAE;IAC3CP,MAAM,CAACU,cAAc,CAACP,IAAI,CAAC;IAC3BC,UAAU,GAAG,CAAC;EAChB;EACAA,UAAU,IAAIE,KAAK;AACrB,CAAC;AACD,IAAIK,MAAM,GAAGL,KAAK,IAAI;EACpBD,QAAQ,CAAEC,KAAK,IAAI,CAAE,CAAC;EACtB,OAAOH,IAAI,CAACS,QAAQ,CAACR,UAAU,GAAGE,KAAK,EAAEF,UAAU,CAAC;AACtD,CAAC;AACD,IAAIS,YAAY,GAAGA,CAACC,QAAQ,EAAEC,WAAW,EAAEC,SAAS,KAAK;EACvD,IAAIC,IAAI,GAAG,CAAC,CAAC,IAAK,EAAE,GAAGC,IAAI,CAACC,KAAK,CAAEL,QAAQ,CAACP,MAAM,GAAG,CAAC,GAAI,CAAC,CAAE,IAAI,CAAC;EAClE,IAAIa,IAAI,GAAGF,IAAI,CAACG,IAAI,CAAE,GAAG,GAAGJ,IAAI,GAAGF,WAAW,GAAID,QAAQ,CAACP,MAAM,CAAC;EAClE,OAAO,CAACe,IAAI,GAAGP,WAAW,KAAK;IAC7B,IAAIQ,EAAE,GAAG,EAAE;IACX,OAAO,IAAI,EAAE;MACX,IAAIjB,KAAK,GAAGU,SAAS,CAACI,IAAI,CAAC;MAC3B,IAAII,CAAC,GAAGJ,IAAI;MACZ,OAAOI,CAAC,EAAE,EAAE;QACVD,EAAE,IAAIT,QAAQ,CAACR,KAAK,CAACkB,CAAC,CAAC,GAAGP,IAAI,CAAC,IAAI,EAAE;QACrC,IAAIM,EAAE,CAAChB,MAAM,KAAKe,IAAI,EAAE,OAAOC,EAAE;MACnC;IACF;EACF,CAAC;AACH,CAAC;AACD,IAAIE,cAAc,GAAGA,CAACX,QAAQ,EAAEQ,IAAI,GAAG,EAAE,KACvCT,YAAY,CAACC,QAAQ,EAAEQ,IAAI,EAAEX,MAAM,CAAC;AACtC,IAAIe,MAAM,GAAGA,CAACJ,IAAI,GAAG,EAAE,KAAK;EAC1BjB,QAAQ,CAAEiB,IAAI,IAAI,CAAE,CAAC;EACrB,IAAIC,EAAE,GAAG,EAAE;EACX,KAAK,IAAIC,CAAC,GAAGpB,UAAU,GAAGkB,IAAI,EAAEE,CAAC,GAAGpB,UAAU,EAAEoB,CAAC,EAAE,EAAE;IACnDD,EAAE,IAAItB,WAAW,CAACE,IAAI,CAACqB,CAAC,CAAC,GAAG,EAAE,CAAC;EACjC;EACA,OAAOD,EAAE;AACX,CAAC;AACD,SAASG,MAAM,EAAED,cAAc,EAAEZ,YAAY,EAAEZ,WAAW,EAAEU,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}